---
title: PTA团队天梯赛║L1-002 打印沙漏
date: 2020-12-30  09:10:00
updated: 2020-12-30  09:10:00
tags: PTA
categories: PTA刷题笔记
description: 
---


# PTA 团队天梯赛║L1-002 打印沙漏

## 一、题目要求

> 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定 17 个“*”，要求按下列格式打印
>
> ```
> *****
> ***
> *
> ***
> *****
> ```
>
> 所谓“沙漏形状”，是指**每行输出奇数个符号**；各行**符号中心对齐**；**相邻两行符号数差 2**；符号数先**从大到小顺序递减到 1**，再从小到大顺序递增；首尾符号数相等。
>
> 给定任意 N 个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。

### 输入格式：

输入在一行给出 1 个正整数 N（≤1000）和一个符号，中间以空格分隔。

### 输出格式：

首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。

### 输入样例：

```in
19 *
```

### 输出样例：

```out
*****
 ***
  *
 ***
*****
2
```

## 二、解题思路

该题目为图形输出类的问题，关键是找到图形输出的规律，由题目找寻下述规律

```
沙漏形状行数必然是奇数 (1,3,5,...,2x+1) //x=0,1,2,3,...
行数为 1 时，符号数为 1
行数为 3 时，符号数为 7，即 1+2*3
行数为 5 时，符号数为 17，即 1+2*3+2*5
...
行数为 i 时，符号数为 1+2*3+2*5+...+2*i
```

因此，先设置打印的沙漏层数 *level* 和 沙漏符号数 *hourglass* 为 1(若用户输入符号数不为 0，则至少可以打印一层沙漏)，用 while 循环累加 *level* 和 *hourglass* 直到能打印最多符号，最后先打印上半部分以及最中心的一个符号，再打印剩余部分的沙漏。

## 三、代码

```c++
#include <iostream>
using namespace std;

int main()
{
    int n, level = 1; //n 为用户输入的符号数，level 为打印的沙漏层数
    int hourglass = 1; //沙漏符号数
    char c; //用户输入的符号
    cin >> n;
    cin >> c;

    while(n / hourglass) //累加寻找能打印的最大沙漏
    {
        level += 2; //层数上下各加一层
        hourglass += 2 * level; //沙漏符号数也增加
    }
    //while 循环最后一次多加了一次要减去
    hourglass -= 2*level; //注意两个算式顺序不能调换
    level -= 2;

    //打印上半个沙漏
    for(int i=0; i < level/2 + 1; i++)
    {
        for(int k=0; k < i; k++) cout << " ";
        for(int m=0 ;m < level-2*i;m++) cout << c;
        cout << endl;
    }
    //打印下半个沙漏
    for(int i=level/2; i >0 ; i--)
    {
        for(int k=0; k < i-1; k++) cout << " ";
        for(int m=0 ;m < level-2*(i-1); m++) cout << c;
        cout << endl;
    }
    cout << n - hourglass << endl;

    return 0;
}
```

## 四、问题反思

1. 在 while 循环寻找能打印的最大沙漏时，最后减去多加的两层时算数顺序不能调换，第一次因为调换了两个算式顺序导致打印出的沙漏出错。
2. 打印上半个沙漏时第一次尝试未将最中间一层考虑进去，将问题复杂化了。
3. 做完打印沙漏部分却遗漏了最后一步输出剩下未使用的符号数，得意忘形，粗心大意了，以后做题中谨记戒骄戒躁，认真阅读题目，做完题后检查一下是否完成全部要求。

---

# 